<p>
  <strong>Broadcasting</strong> in <em>NumPy</em> lets you perform arithmetic between arrays of different shapes
  without writing explicit loops.
  It works by â€œstretchingâ€ one array across the other, as long as their dimensions are compatible.
</p>

<h4>Simple example</h4>
<pre><code class="language-python">
import numpy as np

A = np.ones((3, 3))        # shape (3, 3)
b = np.array([1, 2, 3])    # shape (3,)

A_plus_b = A + b           # b is broadcast across each row
print(A_plus_b)
</code></pre>

<pre><code class="language-text">
[[2. 3. 4.]
 [2. 3. 4.]
 [2. 3. 4.]]
</code></pre>

<p>
  The smaller array (<code>b</code>) is automatically â€œstretchedâ€ to match the larger one (<code>A</code>) along the missing dimension.
</p>

<h4>Broadcasting rules</h4>
<p>
  When performing operations between two arrays:
</p>

<ol>
  <li>Compare their shapes elementwise, starting from the last dimension.</li>
  <li>Two dimensions are compatible if they are equal, or if one of them is 1.</li>
  <li>If they are incompatible in any dimension, broadcasting fails with an error.</li>
</ol>

<pre><code class="language-python">
# Compatible shapes
# (3, 3) + (3,)    â†’ OK (rule 2)
# (4, 1, 6) + (7, 6) â†’ OK â†’ result (4, 7, 6)
# (3, 2) + (3,)    â†’ âŒ error (incompatible: 2 â‰  3)
</code></pre>

<h4>Column vs row broadcasting</h4>
<pre><code class="language-python">
A = np.arange(6).reshape(3, 2)
b_row = np.array([10, 20])    # shape (2,)
b_col = np.array([[100], [200], [300]])  # shape (3, 1)

print(A + b_row)  # adds to each column (row-wise broadcast)
print(A + b_col)  # adds to each row (column-wise broadcast)
</code></pre>

<p>
  This works because <code>(3, 2)</code> and <code>(3, 1)</code> share compatible dimensions:
  the last dimension (1) can be expanded to match 2.
</p>

<h4>Practical tip ğŸ§ </h4>
<p>
  Broadcasting removes the need for slow Python loops, leading to concise, vectorized code.
  But it can also hide accidental shape mismatches â€” always check <code>.shape</code> before relying on it.
</p>

<h4>Visual intuition</h4>
<p>
  If you mentally â€œtileâ€ the smaller array along the dimension with length 1 until it matches the larger one,
  youâ€™re imagining broadcasting correctly â€” but NumPy does it virtually, without extra memory copies.
</p>

<p>
  ğŸ”— Reference:
  <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html" target="_blank">
    NumPy User Guide â€” Broadcasting
  </a>
</p>

